/******************************************************************************
 * SPDX-License-Identifier: MIT-0
 *
 * This file is part of inet.
 * This file is generated by troer, don't edit manually.
 ******************************************************************************/

#include <hed/inet.h>






struct hed_ip_type_bisect_entry {
	const char * str;
	enum hed_ip_type value;
};

static const struct hed_ip_type_bisect_entry hed_ip_type_bisect_array[] = {
	{"IPv4", HED_IPV4},
	{"IPv6", HED_IPV6},
};

const char *
hed_ip_type_to_str(enum hed_ip_type value)
{
	unsigned long i;

	for (i = 0; i < stroll_array_nr(hed_ip_type_bisect_array); i++) {
		if (hed_ip_type_bisect_array[i].value == value)
			return hed_ip_type_bisect_array[i].str;
	}
	return NULL;
}

static int
hed_ip_type_bisect_cmp(const void * __restrict key,
		  const void * __restrict entry,
		  void *                  data __unused)
{
	hed_assert(key);
	hed_assert(entry);

	const char * k = key;
	const char * e = ((const struct hed_ip_type_bisect_entry *)entry)->str;
	return strcmp(k, e);
}

int
hed_ip_type_from_str(const char *str, enum hed_ip_type *value)
{
	hed_assert(str);
	hed_assert(value);

	const struct hed_ip_type_bisect_entry *entry;

	entry = stroll_array_bisect_search(str,
					   hed_ip_type_bisect_array,
					   stroll_array_nr(hed_ip_type_bisect_array),
					   sizeof(hed_ip_type_bisect_array[0]),
					   hed_ip_type_bisect_cmp,
					   NULL);
	if (!entry)
		return -EINVAL;

	*value = entry->value;
	return 0;
}

int
hed_ip_type_dump_str(const char ** buf, size_t nr __unused)
{
	hed_assert(buf);
	hed_assert(nr >= HED_IP_TYPE_NB);

	unsigned long i;

	for (i = 0; i < stroll_array_nr(hed_ip_type_bisect_array); i++) {
		buf[i] = hed_ip_type_bisect_array[i].str;
	}
	return HED_IP_TYPE_NB;
}






int
hed_chk_in_svc(const struct hed_in_svc * value)
{
	hed_assert(value);

	if (hed_check_in_addr(&value->addr))
		return 1;

	if (hed_chk_port(value->port))
		return 1;

	return 0;
}

int
hed_dec_in_svc(struct dpack_decoder * decoder,
	  struct hed_in_svc * __restrict value)
{
	hed_assert(decoder);
	hed_assert(value);

	int ret;

	ret = dpack_array_decode_count_equ(decoder, 2);
	if (ret)
		return ret;

	ret = hed_decode_in_addr(decoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_dec_port(decoder, &value->port);
	if (ret)
		return ret;

	return hed_chk_in_svc(value);
}

int
hed_enc_in_svc(struct dpack_encoder * encoder,
	  const struct hed_in_svc * value)
{
	hed_assert(encoder);
	hed_assert(hed_chk_in_svc(value) == 0);

	int ret;

	ret = dpack_array_begin_encode(encoder, 2);
	if (ret)
		return ret;

	ret = hed_encode_in_addr(encoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_enc_port(encoder, value->port);
	if (ret)
		return ret;


	return 0;
}

int
hed_init_in_svc(struct hed_in_svc * value __unused)
{
	hed_assert(value);

	int ret = 0;

	return ret;
}

void
hed_fini_in_svc(struct hed_in_svc * value __unused)
{
	hed_assert(value);

}




int
hed_chk_in6_svc(const struct hed_in6_svc * value)
{
	hed_assert(value);

	if (hed_check_in6_addr(&value->addr))
		return 1;

	if (hed_chk_port(value->port))
		return 1;

	return 0;
}

int
hed_dec_in6_svc(struct dpack_decoder * decoder,
	  struct hed_in6_svc * __restrict value)
{
	hed_assert(decoder);
	hed_assert(value);

	int ret;

	ret = dpack_array_decode_count_equ(decoder, 2);
	if (ret)
		return ret;

	ret = hed_decode_in6_addr(decoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_dec_port(decoder, &value->port);
	if (ret)
		return ret;

	return hed_chk_in6_svc(value);
}

int
hed_enc_in6_svc(struct dpack_encoder * encoder,
	  const struct hed_in6_svc * value)
{
	hed_assert(encoder);
	hed_assert(hed_chk_in6_svc(value) == 0);

	int ret;

	ret = dpack_array_begin_encode(encoder, 2);
	if (ret)
		return ret;

	ret = hed_encode_in6_addr(encoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_enc_port(encoder, value->port);
	if (ret)
		return ret;


	return 0;
}

int
hed_init_in6_svc(struct hed_in6_svc * value __unused)
{
	hed_assert(value);

	int ret = 0;

	return ret;
}

void
hed_fini_in6_svc(struct hed_in6_svc * value __unused)
{
	hed_assert(value);

}




int
hed_chk_in_net(const struct hed_in_net * value)
{
	hed_assert(value);

	if (hed_check_in_addr(&value->addr))
		return 1;

	if (hed_chk_in_pfx(value->prefix))
		return 1;

	return hed_in_net_check_addr_prefix(value);
}

int
hed_dec_in_net(struct dpack_decoder * decoder,
	  struct hed_in_net * __restrict value)
{
	hed_assert(decoder);
	hed_assert(value);

	int ret;

	ret = dpack_array_decode_count_equ(decoder, 2);
	if (ret)
		return ret;

	ret = hed_decode_in_addr(decoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_dec_in_pfx(decoder, &value->prefix);
	if (ret)
		return ret;

	return hed_chk_in_net(value);
}

int
hed_enc_in_net(struct dpack_encoder * encoder,
	  const struct hed_in_net * value)
{
	hed_assert(encoder);
	hed_assert(hed_chk_in_net(value) == 0);

	int ret;

	ret = dpack_array_begin_encode(encoder, 2);
	if (ret)
		return ret;

	ret = hed_encode_in_addr(encoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_enc_in_pfx(encoder, value->prefix);
	if (ret)
		return ret;


	return 0;
}

int
hed_init_in_net(struct hed_in_net * value __unused)
{
	hed_assert(value);

	int ret = 0;

	return ret;
}

void
hed_fini_in_net(struct hed_in_net * value __unused)
{
	hed_assert(value);

}




int
hed_chk_in6_net(const struct hed_in6_net * value)
{
	hed_assert(value);

	if (hed_check_in6_addr(&value->addr))
		return 1;

	if (hed_chk_in6_pfx(value->prefix))
		return 1;

	return hed_in6_net_check_addr_prefix(value);
}

int
hed_dec_in6_net(struct dpack_decoder * decoder,
	  struct hed_in6_net * __restrict value)
{
	hed_assert(decoder);
	hed_assert(value);

	int ret;

	ret = dpack_array_decode_count_equ(decoder, 2);
	if (ret)
		return ret;

	ret = hed_decode_in6_addr(decoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_dec_in6_pfx(decoder, &value->prefix);
	if (ret)
		return ret;

	return hed_chk_in6_net(value);
}

int
hed_enc_in6_net(struct dpack_encoder * encoder,
	  const struct hed_in6_net * value)
{
	hed_assert(encoder);
	hed_assert(hed_chk_in6_net(value) == 0);

	int ret;

	ret = dpack_array_begin_encode(encoder, 2);
	if (ret)
		return ret;

	ret = hed_encode_in6_addr(encoder, &value->addr);
	if (ret)
		return ret;

	ret = hed_enc_in6_pfx(encoder, value->prefix);
	if (ret)
		return ret;


	return 0;
}

int
hed_init_in6_net(struct hed_in6_net * value __unused)
{
	hed_assert(value);

	int ret = 0;

	return ret;
}

void
hed_fini_in6_net(struct hed_in6_net * value __unused)
{
	hed_assert(value);

}


