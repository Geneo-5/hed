/******************************************************************************
 * SPDX-License-Identifier: MIT-0
 *
 * This file is part of base.
 * This file is generated by troer, don't edit manually.
 ******************************************************************************/

#include <hed/base.h>


struct json_object *
hed_dec_name_to_json(struct dpack_decoder * decoder)
{
	hed_assert(decoder);

	int ret = 0;
	ssize_t len;
	struct stroll_lvstr value;
	struct json_object *obj = NULL;

	ret = hed_init_name(&value);
	if (ret) {
		errno = -ret;
		return NULL;
	}

	len = dpack_decode_lvstr(decoder, &value);
	if (len < 0) {
		errno = (int)-len;
		goto error;
	}

	ret = hed_chk_name(&value);
	if (ret) {
		errno = -ret;
		goto error;
	}

	obj = json_object_new_string(stroll_lvstr_cstr(&value));
error:
	hed_fini_name(&value);
	return obj;
};

int
hed_enc_name_from_json(struct dpack_encoder * encoder,
		    struct json_object * object)
{
	hed_assert(encoder);
	hed_assert(object);

	int ret = 0;
	struct stroll_lvstr value;
	const char * str;

	if (!json_object_is_type(object, json_type_string))
		return -EINVAL;

	ret = hed_init_name(&value);
	if (ret)
		return ret;

	str = json_object_get_string(object);
	hed_assert(str);

	ret = stroll_lvstr_lend(&value, str);
	if (ret)
		goto error;

	ret = hed_chk_name(&value);
	if (ret)
		goto error;

	ret = dpack_encode_lvstr(encoder, &value);
error:
	hed_fini_name(&value);
	return ret;
};







struct json_object *
hed_dec_bauds_to_json(struct dpack_decoder * decoder)
{
	hed_assert(decoder);

	int ret;
	enum hed_bauds value;
	const char *str;

	ret = dpack_decode_int(decoder, (int *)&value);
	if (ret) {
		errno = -ret;
		return NULL;
	}

	str = hed_bauds_to_str(value);
	if (!str) {
		errno = EINVAL;
		return NULL;
	}
	return json_object_new_string(str);
};

int
hed_enc_bauds_from_json(struct dpack_encoder * encoder,
		    struct json_object * object)
{
	hed_assert(encoder);
	hed_assert(object);

	int ret;
	const char * str;
	enum hed_bauds value;

	errno = 0;
	str = json_object_get_string(object);
	if (errno)
		return -errno;

	ret = hed_bauds_from_str(str, &value);
	if (ret)
		return ret;

	return dpack_encode_int(encoder, (int)value);
};




struct json_object *
hed_dec_toggle_to_json(struct dpack_decoder * decoder)
{
	hed_assert(decoder);

	int ret;
	enum hed_toggle value;
	const char *str;

	ret = dpack_decode_int(decoder, (int *)&value);
	if (ret) {
		errno = -ret;
		return NULL;
	}

	str = hed_toggle_to_str(value);
	if (!str) {
		errno = EINVAL;
		return NULL;
	}
	return json_object_new_string(str);
};

int
hed_enc_toggle_from_json(struct dpack_encoder * encoder,
		    struct json_object * object)
{
	hed_assert(encoder);
	hed_assert(object);

	int ret;
	const char * str;
	enum hed_toggle value;

	errno = 0;
	str = json_object_get_string(object);
	if (errno)
		return -errno;

	ret = hed_toggle_from_str(str, &value);
	if (ret)
		return ret;

	return dpack_encode_int(encoder, (int)value);
};

